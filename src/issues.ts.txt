import { RestCollectorClient } from "rest-collector";
import { GithubUser, addUserFromGithubUser, AhoraUser } from "./users";
import { createRestClient, createGithubRestClient } from "./RestClient";
import { getStatuses, AhoraDocStatus } from "./stratuses";
import { updateCommentsForDoc } from "./comments";
import PQueue from "p-queue";
import { stdout } from "single-line-log";
import OrganizationData from "./organizationData";
import { AhoraDocSource } from "./docsources";
import { PULL_REQUEST, ISSUE } from "./docTypes";

export interface GitHubIssueLabel {
    id: number;
}

export interface GitHubIssue {
    title: string;
    body: string;
    state: string;
    number: number;
    assignee: GithubUser | null,
    comments: number;
    id: number;
    user: GithubUser;
    labels: GitHubIssueLabel[];
    locked: boolean;
    closed_at: string | null;
    created_at: string;
    updated_at: string;
    pull_request?: any;
}

export interface Doc {
    docId?: number;
    subject: string;
    description?: string;
    assigneeUserId?: number;
    reporterUserId?: number;
    commentsNumber: number;
    docTypeId: number;
    metadata?: any;
    statusId?: number;
    labels?: number[];
    createdAt: Date | string;
    closedAt: Date | string | null;
    updatedAt: Date | string;
    sourceId?: number
}
export interface AhoraDoc extends Doc {
    id: number;
    htmlDescription?: string;
    organizationId: number;
}


const convertGitIssueToDoc = async (gitHubIssue: GitHubIssue, docSource: AhoraDocSource,organizationData: OrganizationData ): Promise<Doc> => {

    let docType = organizationData.docTypesMap.get(gitHubIssue.pull_request ? PULL_REQUEST: ISSUE);
    const doc: Doc = {
        docId: gitHubIssue.number,
        subject: gitHubIssue.title,
        description: gitHubIssue.body,
        closedAt: gitHubIssue.closed_at,
        commentsNumber: gitHubIssue.comments,
        docTypeId: docType!.id!,
        createdAt: gitHubIssue.created_at,
        updatedAt: gitHubIssue.updated_at,
        sourceId: docSource.id
    }

    if(gitHubIssue.assignee) {
        const ahoraAssignee: AhoraUser = await addUserFromGithubUser(gitHubIssue.assignee);
        doc.assigneeUserId = ahoraAssignee.id
    }

    if(gitHubIssue.state) {
        const status: AhoraDocStatus | undefined =  organizationData.statusesMap.get(gitHubIssue.state);
        if(status) {
            doc.statusId =  status.id;
        }
    }

    if(gitHubIssue.labels) {
        doc.labels = gitHubIssue.labels.map((gitHubLabel) => {
            const mapVal: AhoraLabel | undefined  = organizationData.labelsMap.get(gitHubLabel.id);
            return mapVal!.id
        });
    }

    if(gitHubIssue.user) {
        const ahoraReporter: AhoraUser = await addUserFromGithubUser(gitHubIssue.user);
        doc.reporterUserId = ahoraReporter.id;
    }
    return doc;
}

const docClient: RestCollectorClient = createRestClient("/api/organizations/{organizationId}/docs/{id}");

let tolat = 0;
const updateOrAddAhoraServers = async (doc: Doc, docSource: AhoraDocSource, organizationData: OrganizationData, shouldSyncComments: boolean): Promise<AhoraDoc | null> => {
    if(doc.docId === 67) {
        console.log("doc", tolat, doc);
        tolat = tolat+1;
    }
    const exitingDocs: AhoraDoc[] | null = await (await docClient.get({ query: { docId: doc.docId, sourceId: docSource.id }, params: { organizationId: organizationData.organizationId}})).data;
    let ahoraDoc: AhoraDoc | null = null;
    let syncComments = false;
    if(exitingDocs && exitingDocs.length > 0) {
        const docfromServer: AhoraDoc = exitingDocs[0];
        const result = await docClient.put({ data: doc, params: { id: docfromServer.id, organizationId: organizationData.organizationId}});
        ahoraDoc = result.data as AhoraDoc;

        var docDate = new Date(doc.updatedAt);
        var docAhoraDate = new Date(ahoraDoc.updatedAt);
        var dif = docAhoraDate.getTime() - docDate.getTime();

        if(dif/1000 !==0 && ahoraDoc.commentsNumber!=docfromServer.commentsNumber) {
            syncComments = true;
        }

        syncComments = true;
    }
    else {
        syncComments = true;
        const result = await docClient.post({
            params: { organizationId: organizationData.organizationId},
            data: doc
        });
        ahoraDoc = result.data;
    }

    if(shouldSyncComments && ahoraDoc && syncComments) {
        await updateCommentsForDoc(docSource, ahoraDoc, organizationData);
    }
    return ahoraDoc;
}

const queue = new PQueue({concurrency: 30});
let totalIssues: number = 0;
let reStartInterval: any = null;

setInterval(()=> {
    stdout(`Total: ${totalIssues}, Queue size: ${queue.size}, pending: ${queue.pending}`);
}, 1000)



export const syncIssues = async (docSource: AhoraDocSource, page:number, syncComments: boolean = true, organizationData: OrganizationData): Promise<number> => {  
    const client: RestCollectorClient<GitHubIssue[]> = createGithubRestClient("https://api.github.com/repos/{organization}/{repo}/issues");
    const result = await client.get({ 
        query: { since: docSource.lastUpdated, page, state: docSource.lastUpdated? "all": "open", per_page: 100 },
        params: { organization: docSource.organization, repo: docSource.repo },
    });
    let issues: GitHubIssue[] = result.data;
    totalIssues += issues.length;
    if(issues.length > 0)
    {
        const docPromises: Promise<Doc>[] = issues.map((issue) => {
            if(issue.number === 67) {
                console.log(issue);
            }
            return convertGitIssueToDoc(issue, docSource, organizationData)
        });

        const docs: Doc[] = await Promise.all(docPromises)
        docs.forEach(async (doc) => {

            queue.add(async ()=> {
                try {
                    await updateOrAddAhoraServers(doc, docSource, organizationData, syncComments);
                } catch (error) {
                    console.log(error);
                    queue.pause();
                    queue.add(async ()=> {
                        await updateOrAddAhoraServers(doc, docSource, organizationData, syncComments);
                    });

                    if(reStartInterval) {
                        clearTimeout(reStartInterval);
                    }

                    reStartInterval = setTimeout(()=> {
                        queue.start();
                    }, 10 * 1000);

                }
            });
        });
    }
    return issues.length; 
};